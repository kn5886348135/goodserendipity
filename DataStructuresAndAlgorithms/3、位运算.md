---
title: 位运算
author: Louis
date: 2023-04-05 22:29:39
categories: 数据结构与算法
tags: 位运算
---

#### 认识位运算

- 异或运算：相同为0，不同为1
- 同或运算：相同为1，不同为0
- 异或运算可以理解成无进位相加
- 与运算&
- 或运算|
- 取反~
- 无符号右移>>>
- 左移<<

#### 异或运算的性质

- 0 ^ N == N
- N ^ N == 0
- 异或运算满足交换律和结合律

```Java
    // 交换律
    a ^ b = b ^ a
    // 结合律
    ((a ^ b) ^ c) == (a ^ (b ^ c))
    // a、b两个整数交换，位运算不需要临时变量
    a = a ^ b;
    b = a ^ b; // a ^ b -> a ^ b ^ b -> a ^ 0 -> a
    a = a ^ b; // a ^ b -> a ^ a ^ b -> 0 ^ b -> b
```

#### 题目

- ##### 如何不用额外变量交换两个数

  - 位运算的结合律

- ##### 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数

  - 异或运算的性质，0 ^ N == N，N ^ N == 0，N的奇数次的异或结果还是N。
  - 根据交换律，将奇数次的数交换到最后，数组所有元素异或的结果就是答案。
  - 偶数次异或为0，奇数次异或为本身，遍历每一个元素并异或，最后结果就是奇数次的数字。

- ##### 怎么把一个int类型的数，提取出最右侧的1来

  - 假设int类型变量a，a最右侧的1在index位置，获取int b = ~a + 1
  - 则a的index位置以后都是0，b的index位置及以后都是1，a、b的index之前都是相反的
  - a & b即为答案

```Java
// a的二进制
00010100 00010100 01001000 00000000
// ~a的二进制
11101011 11101011 10110111 11111111
// ~a + 1的二进制
11101011 11101011 10111000 00000000
```

- ##### 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数

  - 假设这两个数是a、b，并且res = a ^ b
  - 遍历数组进行异或计算，并拿到res
  - 计算res最右边的1，记为c，数组中除a、b之外的任意其它数记为arr[i]，则arr[i] & c == 0。因为其他的数经过异或的交换律和结合律最后结果都是0，不存在最右边的1.
  - res是ab经过异或计算得到的，所以最右边的1必定属于a、b其中一个。
  - 遍历数组并判断是否是a、b之一，拿到一个结果，记为a
  - res ^ a拿到b

- ##### 一个数组中有一种数出现K次，其他数都出现了M次，M > 1,  K < M。找到，出现了K次的数。要求，额外空间复杂度O(1)，时间复杂度O(N)

  - 假设a出现k次，b出现m次
  - 将所有数字的二进制位相加，则t[i] % m就是a的二进制在i位置次数，要么是0，要么是k

- ##### 位运算实现加减乘除 LeetCode29

  - 加法add
    - a ^ b结果为无进位相加，(a & b) << 1是进位信息，递归到进位信息为0，注意中间变量。
  - 减法delete
    - add(a, add(~b,1))，取反加1后为相反。
  - 乘法
    - a左移b的每一位进制的位数相加。
    - b  = 2^k^ + 2^k-1^  + 2^k-2^ + 2^k-3^ + 2^k-4^ + 2^k-5^ + ...
    - $a \times 2^k$ = a << k
  - 除法
    - 分别处理除数、被除数为Integer.MIN_VALUE的场景
    - a / b = 2^i^ + 2^j^ + 2^k^ + 2^p^ + 2^q^ + 2^r^ + ...，并且i、j、k、p、q、r依次减小
    - 先取绝对值，a右移到刚好大于等于b，拿到一个商，最后所有商相加，补上符号。对系统最小值特殊处理。

```Java
        // 核心代码
        for (int i = 30; i >= 0; i = subtraction(i, 1)) {
            // dividend为Integer.MIN_VALUE的时候，>>>左侧补的都是0，>>左侧补的都是1
            if ((dividend >> i) >= divisor) {
                ans |= (1 << i);
                dividend = subtraction(dividend, divisor << i);
            }
        }
```

#### 其他

- ##### 相反数

  - 一个数的相反数为取反加1。取反的结果和原来的数相加结果为2^32^-1,再加1则进位为0。

```shell
# 2^32^-1二进制为
11111111 11111111 11111111 11111111
# 例如 int a = 1024;二进制为
00000000 00000000 00001000 00000000
# 取反后
11111111 11111111 11110111 11111111
# 相加为
11111111 11111111 11111111 11111111
# 再加1则溢出为0
a + (~a) + 1 = 0; 则-a = (~a) + 1;
```

- ##### 溢出

  - Integer.MIN_VALUE取反加一后仍然为Integer.MIN_VALUE。
  - Integer.MIN_VALUE二进制为100000000 00000000 00000000 0000000
  - Integer.MAX_VALUE加1后溢出为Integer.MIN_VALUE
  - Integer.MIN_VALUE减一则溢出为Integer.MAX_VALUE。

- ##### 位图

  - 位图的功能
    - 保存已知最大值的集合，比如一亿bit标记用户是否登录
  - 位图的好处
    - 极大的节省空间，一个bit位标记true/false信息
  - 位图的实现
    - java.util.BitSet

```Java
// bitmap实现加减法
public class BitMap {
    private long[] bits;

    public BitMap(int max) {
        bits = new long[(max + 64) >> 6];
    }

    // 给定数字除以64的结果result，模64的结果mod分开保存，bits[result]位置的mod位设置为1
    public void add(int num){
        // num & 63等于num % 64
        bits[num >> 6] |= (1L << (num & 63));
    }

    public void delete(int num){
        bits[num >> 6] &= ~(1L << (num & 63));
    }

    public boolean contains(int num){
        return (bits[num >> 6] & (1L << (num & 63))) != 0;
    }
}
```
