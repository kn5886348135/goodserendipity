---
title: 堆
author: Louis
date: 2023-04-10 04:43:50
categories: 数据结构与算法
tags: 堆
---

&emsp;&emsp;[堆](https://en.wikipedia.org/wiki/Heap_(data_structure))是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于/小于等于其父亲的键值。每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆。
&emsp;&emsp;（小根）堆主要支持的操作有：插入一个数、查询最小值、删除最小值、合并两个堆、减小一个元素的值。
&emsp;&emsp;一些功能强大的堆（可并堆）还能（高效地）支持 merge 等操作。一些功能更强大的堆还支持可持久化，也就是对任意历史版本进行查询或者操作，产生新的版本

#### 堆的特点

- 堆结构就是用数组实现的完全二叉树结构
- 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
- 完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
- 堆结构的heapInsert与heapify操作
- 堆结构的增大和减少
- 优先级队列结构，就是堆结构
- 堆的父子节点有大小关系，左右节点没有大小限制。

#### 堆排序

&emsp;&emsp;[堆排序](https://en.wikipedia.org/wiki/Heapsort)的逻辑

- 先让整个数组都变成大根堆结构，建立堆的过程
  - 从上到下的方法，时间复杂度为O(N*logN)
  - 从下到上的方法，时间复杂度为O(N)
- 把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，递归调整堆，时间复杂度为O(N*logN)
- 堆的大小减小成0之后，排序完成。

#### 改写堆

&emsp;&emsp;JDK的堆(PriorityQueue)无法做到

- 已经入堆的元素，如果参与排序的指标方法变化，系统提供的堆无法做到时间复杂度O(logN)调整，都是O(N)的调整。
- 系统提供的堆只能弹出堆顶，做不到自由删除任何一个堆中的元素，无法在时间复杂度O(logN)内完成，一定会高于O(logN)。根本原因是无反向索引表。

&emsp;&emsp;改写堆的要点

- 建立反向索引表indexMap
- 建立比较器
- push需要heapify、pop需要heapify，remove先将节点交换到heapSize位置，移除后调整。所有操作都要更新indexMap。

---

##### 乱序不超过k长度的数组排序

&emsp;&emsp;已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。请选择一个合适的排序策略，对这个数组进行排序。
&emsp;&emsp;将前k个元素放入ProritityQueue，保证数组在k长度有序，遍历完数组即为整体有序。

##### 最大线段重合问题

&emsp;&emsp;给定很多线段，每个线段都有两个数[start, end]，表示线段开始位置和结束位置，左右都是闭区间。

- 线段的开始和结束位置一定都是整数值
- 线段重合区域的长度必须>=1
- 返回线段最多重合区域中，包含了几条线段？

1. 将所有线段按照start升序排序
2. 构造堆，保存当前重合所有重合线段的end, heap的size就是当前重合线段的数量
3. 遍历所有线段，如果出现不重合线段则弹出不重合的线段，如果重合则加入end

##### 给购买次数最多的前K名用户颁奖

&emsp;&emsp;给定一个整型数组，int[] arr；和一个布尔类型数组，boolean[] op。两个数组一定等长，假设长度为N，arr[i]表示客户编号，op[i]表示客户操作

```shell
    arr = [ 3, 3, 1, 2, 1, 2, 5…
    op  = [ T, T, T, T, F, T, F…
```

&emsp;&emsp;依次表示：3用户购买了一件商品，3用户购买了一件商品，1用户购买了一件商品，2用户购买了一件商品，1用户退货了一件商品，2用户购买了一件商品，5用户退货了一件商品…

&emsp;&emsp;一对arr[i]和op[i]就代表一个事件：用户号为arr[i]，op[i] == T就代表这个用户购买了一件商品，op[i] == F就代表这个用户退货了一件商品。现在你作为电商平台负责人，你想在每一个事件到来的时候，都给购买次数最多的前K名用户颁奖。所以每个事件发生后，你都需要一个得奖名单（得奖区）。

&emsp;&emsp;得奖系统的规则：

1. 如果某个用户购买商品数为0，但是又发生了退货事件，则认为该事件无效，得奖名单和上一个事件发生后一致，例子中的5用户
2. 某用户发生购买商品事件，购买商品数+1，发生退货事件，购买商品数-1
3. 每次都是最多K个用户得奖，K也为传入的参数。如果根据全部规则，得奖人数确实不够K个，那就以不够的情况输出结果
4. 得奖系统分为得奖区和候选区，任何用户只要购买数>0，一定在这两个区域中的一个
5. 购买数最大的前K名用户进入得奖区，在最初时如果得奖区没有到达K个用户，那么新来的用户直接进入得奖区
6. 如果购买数不足以进入得奖区的用户，进入候选区
7. 如果候选区购买数最多的用户，已经足以进入得奖区，该用户就会替换得奖区中购买数最少的用户（大于才能替换），如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户，如果候选区中购买数最多的用户有多个，机会会给最早进入候选区的用户
8. 候选区和得奖区是两套时间，因用户只会在其中一个区域，所以只会有一个区域的时间，另一个没有。从得奖区出来进入候选区的用户，得奖区时间删除，进入候选区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i，从候选区出来进入得奖区的用户，候选区时间删除，进入得奖区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i
9. 如果某用户购买数==0，不管在哪个区域都离开，区域时间删除，离开是指彻底离开，哪个区域也不会找到该用户。如果下次该用户又发生购买行为，产生>0的购买数，会再次根据之前规则回到某个区域中，进入区域的时间重记
&emsp;&emsp;请遍历arr数组和op数组，遍历每一步输出一个得奖名单

```Java
public List<List<Integer>>  topK (int[] arr, boolean[] op, int k)
```

&emsp;&emsp;自定义堆，添加反向索引表。按照业务逻辑进行遍历，调整中奖区、候选区。
