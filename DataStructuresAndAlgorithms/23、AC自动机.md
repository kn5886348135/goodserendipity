---
title: AC自动机
author: Louis
date: 2023-04-26 17:52:21
categories: 数据结构与算法
tags: [AC,Aho–Corasick算法]
---
&emsp;&emsp;[AC 自动机](https://oi-wiki.org/string/ac-automaton/)(Aho–Corasick算法)是 以 Trie 的结构为基础，结合 KMP 的思想 建立的自动机，用于解决多模式匹配等任务。它是基于前缀搜索，使用了确定有限自动机原理的，字符串多模匹配算法。
&emsp;&emsp;确定有限自动机 (Deterministic Finite Automaton, DFA)，自动机(Automaton)是一个代码块,只做一件事——接收输入值，和状态值，输出同为状态值的结果。有限(Finite)是指自动机接收、输入的状态种类是有限的。否则就是英菲尼迪(Infinite)。确定(Deterministic )是指自动机的输出状态是单一的一个状态，否则就是NFA。

#### AC自动机算法核心

1. 把所有模式串生成一棵前缀树
2. 前缀树节点增加fail指针
3. fail指针的含义：如果必须以当前字符char1结尾，以char1结尾的字符串str1，fail的子节点为char2，以char2结尾的字符串str2, 则str2是str1的后缀，fail保证str2的长度是最长的。

#### fail指针的定义

1. trieTree的每一个节点都有一个fail指针，头结点的fail指向null，trieTree第二层节点的fail全部指向头结点。(宽度优先)
2. 取其余任意一个节点X，X的父节点为Y，Y节点fail指针指向的节点Z，Y到X的路径为path
    - 如果Z到Z的子节点P的路径包含path，则X的fail指向Z
    - 如果Z到Z的子节点P的路径不包含path，fail指针递归指向Z的fail指针，递归终止条件为fail到子节点的路径包含path或者fail为空

&emsp;&emsp;fail指针的实质是快速找到匹配失败后的下一个选择的节点，减少匹配过程中的回溯。

### 证明

&emsp;&emsp;当前考虑的节点为任意节点P，根据trie树和fail指针的规则可以得到结论

1. 某个节点的所有子节点都是不同的
2. 任意节点的父节点都有fail指针
3. p的父节点p1、p2、p3、$p_k$、$p_{k+1}$、$p_{n-1}$、$p_n$，并且p1、p2、p3、$p_k$的fail全部指向头结点，$p_{k+1}$、$p_{n-1}$、$p_n$是从头结点开始的trie的路径，0 &le; k &le; n。

&emsp;&emsp;假设有另外一条路径anotherPath是以P结尾的后缀并且更长，则

1. anotherPath不是$p_{k+1}$、$p_{n-1}$、$p_n$这些节点构成，则说明trie树的某个子节点存在重复
2. anotherPath和$p_{k+1}$、$p_{n-1}$、$p_n$这些节点重合，则不会更长。

### 示例

&emsp;&emsp;模式串abcdex，匹配串abcdef、cdey、ex

1. 匹配abcdef时，f匹配失败，fail指向cdey的e节点，淘汰ab
2. 匹配cdey时，y匹配失败，fail指向ex的e节点，淘汰cd

&emsp;&emsp;给定敏感词样本{abd,abdk, abchijn, chnit, ijabdf, ijaij}，则它的fail指针为
![AC自动机](https://www.goodserendipity.com/asserts/data-structures-and-algorithms/AC-automaton-fail.png)

### 单模式串匹配问题

&emsp;&emsp;单模式匹配问题（Single Pattern Matching）：给定一个文本串str，再给定一个特定模式串match。要求从文本串str找出特定模式串match的所有出现位置。

&emsp;&emsp;根据在文本中搜索模式串方式的不同，可以将单模式匹配算法分为

1. 基于前缀搜索方法：在搜索窗口内从前向后（沿着文本的正向）逐个读入文本字符，搜索窗口中文本和模式串的最长公共前缀。例如著名的 Knuth-Morris-Pratt (KMP) 算法和更快的 Shift-Or 算法。

2. 基于后缀搜索方法：在搜索窗口内从后向前（沿着文本的反向）逐个读入文本字符，搜索窗口中文本和模式串的最长公共后缀。使用这种搜索算法可以跳过一些文本字符，从而具有亚线性的平均时间复杂度。例如最著名的 Boyer-Moore 算法，以及 Horspool 算法、Sunday (Boyer-Moore 算法的简化) 算法。

3. 基于子串搜索方法：在搜索窗口内从后向前（沿着文本的反向）逐个读入文本字符，搜索满足既是窗口中文本的后缀，也是模式串的子串的最长字符串。与后缀搜索方法一样，使用这种搜索方法也具有亚线性的平均时间复杂度。这种方法的主要缺点在于需要识别模式串的所有子串，这是一个非常复杂的问题。比如Rabin-Karp 算法、Backward Dawg Matching (BDM) 算法、Backward Nondeterministtic Dawg Matching (BNDM) 算法和 Backward Oracle Matching (BOM) 算法。其中，Rabin-Karp 算法使用了基于散列的子串搜索算法。

### 多模式串匹配问题

&emsp;&emsp;多模式匹配问题（Multi Pattern Matching）：给定一个文本串text，再给定一组模式串集合P，其中每个模式串是定义在有限字母表上的字符串。要求从文本串text中找到模式串集合P中所有模式串的所有出现位置。
&emsp;&emsp;模式串集合P中的一些字符串可能是集合中其他字符串的子串、前缀、后缀，或者完全相等。解决多模式串匹配问题最简单的方法是利用单模式串匹配算法搜索 r 遍。这将导致预处理阶段的最坏时间复杂度为O(| P|)，搜索阶段的最坏时间复杂度为O(r $ \times $ n)
。

&emsp;&emsp;根据在文本中搜索模式串方式的不同，可以将多模式串匹配算法分为

1. 基于前缀搜索方法：搜索从前向后（沿着文本的正向）进行，逐个读入文本字符，使用在P上构建的自动机进行识别。对于每个文本位置，计算既是已读入文本的后缀，同时也是中某个模式串的前缀的最长字符串。例如著名的 Aho-Corasick Automaton (AC 自动机) 算法、Multiple Shift-And 算法。
2. 基于后缀搜索方法：搜索从后向前（沿着文本的反向）进行，搜索模式串的后缀。根据后缀的下一次出现位置来移动当前文本位置。这种方法可以避免读入所有的文本字符。例如[Commentz-Walter](https://en.wikipedia.org/wiki/Commentz-Walter_algorithm) 算法（Boyer-Moore 算法的扩展算法）、Set Horspool 算法（Commentz-Walter 算法的简化算法）、Wu-Manber 算法。
3. 基于子串搜索方法：搜索从后向前（沿着文本的反向）进行，在模式串的长度为min(len(p^i^))的前缀中搜索子串，以此决定当前文本位置的移动。这种方法也可以避免读入所有的文本字符。例如Multiple BNDM 算法、Set Backward Dawg Matching (SBDM) 算法、Set Backwrad Oracle Matching (SBOM) 算法。

&emsp;&emsp;多模式串匹配算法大多使用了一种基本的数据结构：字典树（Trie Tree）。著名的Aho-Corasick Automaton (AC 自动机) 算法就是在 KMP 算法的基础上，与字典树结构相结合而诞生的。而AC 自动机算法也是多模式串匹配算法中最有效的算法之一。

### 双数组trie树

&emsp;&emsp;双数组trie树(Double-Array Trie)是一种空间复杂度较低，应用于字符区间比较大的语言(中文、日文等)分词的算法。
