---
title: 二叉树
author: Louis
date: 2023-04-11 17:46:23
categories: 数据结构与算法
tags: binary tree
---

&emsp;&emsp;[二叉树](https://en.wikipedia.org/wiki/Binary_tree)是一种很基础的数据结构，二叉树仅要求左右节点和父节点。搜索二叉树要求左节点小于父节点、右节点大于父节点，有序表对搜索二叉树的要求更严格，避免搜索二叉树退化成链表。[AVL](https://en.wikipedia.org/wiki/AVL_tree)要求左右子树的高度差不超过1，[Size-balanced tree](https://oi-wiki.org/ds/sbt/)要求左右子树的节点个数相差不超过两倍，[红黑树](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)的限制更复杂，在调整平衡的时候需要考虑的场景更多。AVL Tree每次变更节点时都需要调整平衡，Size balance Tree在删除的时候可以不调整平衡，红黑树调整平衡的次数很少、均摊时间复杂度是O(1)。
&emsp;&emsp;完全二叉树，只有叶子节点最右侧是空的。平衡二叉树，左右子树高度差不超过1

#### 二叉树的遍历

&emsp;&emsp;可以用递归和非递归方式实现二叉树的先序、中序、后序遍历。二叉树的递归序，每一个节点都会经过3次，先序、中序、后序都可以基于递归序实现，第一次到达一个节点就打印就是先序、第二次打印即中序、第三次即后序。
&emsp;&emsp;利用Stack或者Queue实现系统的弹栈压栈操作，可以非递归方式实现二叉树的先序、中序、后序遍历。也可以使用morris实现二叉树的先序、中序、后序遍历。
&emsp;&emsp;[<font color="red">一种无需队列的层序遍历算法IDDFS</font>](https://zhuanlan.zhihu.com/p/452139663)

- 先序：头、左、右
- 中序：左、头、右
- 后序：左、右、头

#### 二叉树的递归套路

- 假设以X节点为头，并且可以获取左子树和右子树的信息
- 计算以X为头节点的树，得到答案的可能性
- 列出所有可能性后，确定到底需要向左树和右树要什么样的信息
- 把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S
- 递归函数都返回S
- 在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息

#### 实现二叉树的按层遍历

- 宽度优先遍历，用队列
- 依次出队列level层的节点，并入队列level+1层的left、right节点

#### 实现二叉树的序列化和反序列化

- 先序遍历序列化和反序列化
- 后序遍历序列化和反序列化
- 按层方式序列化和反序列化
- 中序遍历无法找到root，不同的二叉树中序结果可能相同，所以不能反序列化

```shell
root 2 、left 1 的中序结果是null 1 null 2 null
root 1 、right 2 的中序结果也是null 1 null 2 null
```

#### 将多叉树编码为二叉树 LeetCode431

- 收费题目，多叉树的每一层以null分割。
- 深度优先遍历，将多叉树的X节点的所有子节点作为二叉树X的右节点，拉长成一个链表
- 解码的时候也是递归，将链表的元素收集作为子节点

#### 二叉树的宽度

&emsp;&emsp;求二叉树最宽的层有多少个节点

#### 找出某个节点的后继节点

&emsp;&emsp;二叉树结构如下定义：

```Java
Class Node {
 V value;
 Node left;
 Node right;
 Node parent;
}
```

&emsp;&emsp;给你二叉树中的某个节点，返回该节点的后继节点。前驱节点是指对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的前一个节点;后继节点是指对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的后一个节点。

- 右子树的最左节点即是答案
- 右子树为空，并且当前节点是parent的左节点，parent也是答案

#### 折纸问题

&emsp;&emsp;请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。
&emsp;&emsp;给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。例如:N=1时，打印: down N=2时，打印: down down up。

- 中序打印凹凸

#### 判断两颗二叉树是否相同 LeetCode100

- 判断当前节点是否为空，值是否相等
- 递归比较左右节点

#### 判断一个二叉树是否对称 LeetCode101

- node1 = node.left、node2 = node.right
- node1.left == node2.right && node1.right == node2.left
- 递归比较

#### 获取一个二叉树的高度 LeetCode104

- 递归获取左子树的高度和右子树的高度

#### 用先序数组和中序数组重建一个二叉树 LeetCode105

&emsp;&emsp;先序遍历的第一个元素是头结点，先序遍历剩余部分左边是左节点的先序，右边是右节点的先序，中序遍历左边是左节点的中序，右边是右节点的中序。递归构建二叉树，递归函数入参为先序遍历的起止index，中序遍历的起止index，返回头结点。

#### 祖先节点   先序遍历和后序遍历的交集

&emsp;&emsp;X是一棵二叉树的某一个节点，A是二叉树先序遍历X的左边部分，B是二叉树后序遍历X右边部分，AB相交的结果是且仅是X的所有父节点。

1. X的所有父节点在先序遍历的左边，X的所有父节点在后序遍历的右边，交集一定包含所有父节点
2. X的所有子节点在先序遍历的左边，X的所有子节点在后序遍历的左边，交集一定不包含所有子节点
3. A不包含所有祖先节点的右兄弟节点，B不包含所有祖先节点的左兄弟节点

&emsp;&emsp;X的所有祖先节点、X自己、X的子节点、X或者X的父节点作为左树的右兄节点、X或者X的父节点作为右树的左兄节点。

#### 二叉树按层遍历收集节点 LeetCode107 LeetCode102

&emsp;&emsp;使用LinkedList(有序，快速插入)，递归将每一层的节点入队、出队。

#### 平衡二叉树 LeetCode110

&emsp;&emsp;给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树。
&emsp;&emsp;判断二叉树是否是平衡二叉树，左子树的高度和右子树的高度相差不超过1，则称为平衡二叉树。

#### 搜索二叉树 LeetCode98

&emsp;&emsp;判断二叉树是否是[搜索二叉树](https://en.wikipedia.org/wiki/Binary_search_tree)。用递归或者morris遍历解决。

#### 路径总和 LeetCode112

- 递归计算路径和
- 左子树和右子树分别递归

#### 达标路径总和 LeetCode113

&emsp;&emsp;同LeetCode112，收集所有达标路径并返回。

#### 二叉树的最大距离

&emsp;&emsp;给定一颗二叉树的头结点，任何两个节点之间都存在距离，返回整颗二叉树的最大距离。

#### 判断完全二叉树

&emsp;&emsp;判断二叉树是否是完全二叉树
&emsp;&emsp;按照二叉树的定义判断，逐行遍历

#### 满二叉树

&emsp;&emsp;给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树。

#### 最大的二叉搜索子树

&emsp;&emsp;给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点。

#### 最大的二叉搜索子树大小

&emsp;&emsp;给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小。

#### 最低公共祖先

&emsp;&emsp;给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先。a、b可能在head的左右子树，也可能在同一棵子树。

- 遍历整棵树，用map保存所有节点的父节点
- 遍历a的所有父节点，用set保存
- 遍历b的所有父节点，看set中是否存在
- 后序遍历递归套路

#### 派对的最大快乐值

&emsp;&emsp;员工信息的定义如下:

```Java
class Employee {
    // 快乐值
    public int happy;
    // 直接下级
    List<Employee> subordinates;
}
```

 &emsp;&emsp;公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。 叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。
&emsp;&emsp;这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：

1. 如果某个员工来了，那么这个员工的所有直接下级都不能来
2. 派对的整体快乐值是所有到场员工快乐值的累加
3. 你的目标是让派对的整体快乐值尽量大

&emsp;&emsp;给定一棵多叉树的头节点boss，请返回派对的最大快乐值。
