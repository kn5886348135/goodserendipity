---
title: 排序
author: Louis
date: 2023-04-08 20:48:57
categories: 数据结构与算法
tags: 排序
---

&emsp;&emsp;不基于比较的排序，也叫桶排序。对数据样本有要求，但是特定场景可以做到O(N)时间复杂度，基于比较的排序最好能做到O($N \times logN$)。计数排序需要指定上下限，基数排序要求非负、能用十进制理解的样本。

* 不基于比较的排序，对样本数据有严格要求，不容易改写
* 基于比较的排序，只要规定好两个样本怎么比较大小就可以直接复用
* 基于比较的排序，时间复杂度的极限是O($N \times logN$)
* 时间复杂度O($N \times logN$)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的
* 为了绝对的速度选择快排、为了省空间选堆排序、为了稳定性选归并
* jdk中为了考虑稳定性，Arrays.sort，基础类型使用快排，有比较器使用归并排序。
* 充分利用O($N \times logN$)和O(N^2^)排序各自的优势，O(N^2^)排序的常数项小，在数据样本不大(比如小于60)的时候是比O($N \times logN$)要快的。
* ~~归并排序的额外空间复杂度可以变成O(1)，“归并排序 内部缓存法”，但是将变得不再稳定。~~
* ~~“原地归并排序" 是垃圾贴，会让时间复杂度变成O(N^2^)~~
* ~~快速排序稳定性改进，“01 stable sort”，但是会对样本数据要求更多。~~

&emsp;&emsp;桶排序有计数排序、基数排序等

* 桶排序思想下的排序都是不基于比较的排序
* 时间复杂度为O(N)，额外空间负载度O(M)
* 应用范围有限，需要样本的数据状况满足桶的划分

&emsp;&emsp;计数排序和基数排序的特点

* 计数排序要求，样本是整数，且范围比较窄
* 基数排序要求，样本是10进制的正整数
* 一旦要求稍有升级，改写代价增加

&emsp;&emsp;排序算法稳定性是指同样大小的样本再排序之后不会改变相对次序。对基础类型来说，稳定性毫无意义，对非基础类型来说，稳定性有重要意义。有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的。

|name          |Best              |Average               |Worst                 |空间复杂度|类型    |稳定性|
|--------------|------------------|----------------------|----------------------|---------|--------|-----|
|Quick Sort    |O($N \times logN$)|O($N \times logN$)    |O(N^2^)               |O($logN$)|比较排序 |不稳定|
|Merge Sort    |O($N \times logN$)|O($N \times logN$)    |O($N \times logN$)    |O(N)     |比较排序 |稳定|
|Tim Sort      |O(N)              |O($N \times logN$)    |O($N \times logN$)    |O(N)     |||
|Heap Sort     |O($N \times logN$)|O($N \times logN$)    |O($N \times logN$)    |O(1)     ||不稳定|
|Bubble Sort   |O(N)              |O(N^2^)               |O(N^2^)               |O(1)     |比较排序 |稳定|
|Insertion Sort|O(N)              |O(N^2^)               |O(N^2^)               |O(1)     |比较排序 |稳定|
|Selection Sort|O(N^2^)           |O(N^2^)               |O(N^2^)               |O(1)     |比较排序  |不稳定|
|Tree Sort     |O($N \times logN$)|O($N \times logN$)    |O(N^2^)               |O(N)     |
|Shell Sort    |O($N \times logN$)|O($(N \times logN)^2$)|O($(N \times logN)^2$)|O(1)     ||不稳定|
|Bucket Sort   |O(N+k)            |O(N+k)                |O(N^2^)               |O(N)     |不基于比较|
|Radix Sort    |O($N \times k$)   |O($N \times k$)       |O($N \times k$)       |O(N+k)   ||稳定|
|Counting Sort |O(N+k)            |O(N+k)                |O(N+k)                |O(k)     |不基于比较|稳定|
|Cube Sort     |O(N)              |O($N \times logN$)    |O($N \times logN$)    |O(N)     |||

</br>

#### 选择排序

&emsp;&emsp;双层循环，内层循环完成后获取最小值，内层循环每次将最小值放到i位置。0-i之间认为是有序，i-n之间是原始数据，从i-n之间选择最小的元素放到index为i的地方。是不稳定的排序。

```Java
private static void selectionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }

    int length = arr.length;
    int tmp;
    for (int i = 0; i < length; i++) {
        int index = i;
        for (int j = i; j < length; j++) {
            // 小于号避免位置交换
            index = arr[j] < arr[index] ? j : index;
        }
        if (index == i) {
            continue;
        }
        tmp = arr[i];
        arr[i] = arr[index];
        arr[index] = tmp;
    }
}
```

#### 冒泡排序

&emsp;&emsp;[冒泡排序](https://en.wikipedia.org/wiki/Bubble_sort)是双层循环，内层循环两两交换，内层循环完成后将最大值冒泡到最右边。外层循环index从大到小，内层循环index从小到大。稳定排序。

```Java
private static void bubbleSort(int[] arr){
    int length = arr.length;
    if (arr == null || length < 2) {
        return;
    }

    int tmp;
    for (int i = length - 1; i > 0; i--) {
        for (int j = 0; j < i; j++) {
            if (arr[j + 1] < arr[j]) {
                tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
            }
        }
    }
}
```

#### 插入排序

&emsp;&emsp;每次获取原始数据最前面的那个元素交换到左侧已经有序的数组。双层循环，外层循环每次递增并获取i，内层循环使用i挨个和0-1的数据比较并交换。如果i比i-1大或者内层循环到了最左侧则终止循环。稳定排序。

```Java
    public static void insertionSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int i = 1; i < arr.length; i++) {
            for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
                CommonUtil.swap(arr, j, j + 1);
            }
        }
    }
```

#### 归并排序

&emsp;&emsp;归并排序可以用递归方式实现，所有的递归都可以改写成非递归方式。

* 整体是递归，左边排好序+右边排好序+merge让整体有序
* 让其整体有序的过程里用了排外序方法
* 利用master公式来求解时间复杂度

&emsp;&emsp;非递归方式，使用步长的概念和merge实现。

* 步长mergeSize从1开始增长，1、2、4、8... $2 \times mergeSize $ &gt; N终止。
* 将整个数组按照步长分成若干组，组内merge使有序但整体无序
* mergeSize达到最大，merge操作结束，数组整体有序。
* mergeSize >> 1以后，left、right必须刚好覆盖上一轮循环的两个left和right

&emsp;&emsp;归并排序复杂度表达式为T(N) = 2*T($ \frac{N}{2} $) + O(N^1^)，根据master可知时间复杂度为O($N \times logN$)，merge过程需要辅助数组，所以额外空间复杂度为O(N)。归并排序的实质是把比较行为变成了有序信息并传递，比O(N^2^)的排序快。

```Java
    public static void mergeSort2(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        int mergeSize = 1;
        int left;
        int right;
        int middle;
        while (mergeSize < arr.length) {
            // 下一个mergeSize，从数组头部开始合并
            left = 0;
            while (left < arr.length) {
                if (mergeSize >= arr.length - left) {
                    break;
                }
                // middle = left + mergeSize; 为什么排序结果就不对
                // 下一轮mergeSize << 1，left、right必须刚好覆盖这一次的left、right
                middle = left + mergeSize - 1;
                right = middle + Math.min(mergeSize, arr.length - middle - 1);
                merge1(arr, left, middle, right);
                left = right + 1;
            }
            // 防止溢出
            if (mergeSize > (arr.length >> 1)) {
                break;
            }
            // 步长左移
            mergeSize <<= 1;
        }
    }
```

#### 随机快排

&emsp;&emsp;时间复杂度O($N \times logN$)，额外空间复杂度O(logN)。[快排](https://en.wikipedia.org/wiki/Quicksort)使用荷兰国旗技巧和随机pivot进行排序。

* 划分值pivot越靠近中间，性能越好；越靠近两边，性能越差
* 随机选一个数pivot进行划分的目的就是让好情况和差情况都变成概率事件
* 把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是1/N
* 那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！

#### 荷兰国旗问题

* 给定一个数组arr，和一个整数num。请把小于num的数放在数组的左边，等于num的数放在中间，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)

```Java
    private static int[] netherlandsFlag(int[] arr, int left, int right) {
        if (left > right) {
            return new int[]{-1, -1};
        }

        if (left == right) {
            return new int[]{left, right};
        }
        // = arr[right]的位置
        int scopeLeft = left - 1;
        int scopeRight = right;
        // left...right的任意一个位置
        int index = left;
        while (index < scopeRight) {
            // index右移
            if (arr[index] == arr[right]) {
                index++;
            } else if (arr[index] < arr[right]) {
                // < arr[right] 交换到左边
                // scopeLeft...index-1都是=arr[right]
                CommonUtil.swap(arr, index++, ++scopeLeft);
            } else {
                // > arr[right]交换到右边
                // arr[--scopeRight]的大小不确定，所以index不动
                CommonUtil.swap(arr, index, --scopeRight);
            }
        }
        CommonUtil.swap(arr, scopeRight, right);
        // arr[scopeLeft] < arr[right]，所以要+1
        return new int[]{scopeLeft + 1, scopeRight};
    }
```

##### 小和问题

&emsp;&emsp;在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和。

```shell
     例子： [1,3,4,2,5]
     1左边比1小的数：没有
     3左边比3小的数：1
     4左边比4小的数：1、3
     2左边比2小的数：1
     5左边比5小的数：1、3、4、 2
     所以数组的小和为1+1+3+1+1+3+4+2=16
```

&emsp;&emsp;小和问题等价于每一个数，右边比它大的每一个数累加一次，在合并的过程中累加。left &lt;  p &lt;middle，middle+1 &lt; q &lt; right，arr[p] &lt; arr[q] 则[q, right]区间的所有数都累加一次arr[p]。

##### 逆序对

&emsp;&emsp;在一个数组中，任何一个前面的数a，和任何一个后面的数b，如果(a,b)是降序的，就称为逆序对。返回数组中所有的逆序对。
&emsp;&emsp;逆序对不一定是相邻的，使用归并排序对左右两部分逆序排序，每次合并的时候拿到逆序对个数。

##### 大于两倍 LeetCode493

&emsp;&emsp;在一个数组中，对于每个数num，求有多少个后面的数 * 2 依然&lt;num，求总个数

```shell
     比如：[3,1,7,0,2]
     3的后面有：1，0
     1的后面有：0
     7的后面有：0，2
     0的后面没有
     2的后面没有
     所以总共有5个
```

&emsp;&emsp;递归合并操作，判断&gt;2 $\times$ num。先转成long类型再 $ \times 2$ ,避免溢出。不同于小和问题、逆序对，需要完全遍历左边和右边。小和问题和逆序对在左边或者右边越界的时候递归终止。

##### 奇偶分组

&emsp;&emsp;在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变。要求时间复杂度做到O(N)，额外空间复杂度做到O(1)
&emsp;&emsp;桶排序是否可以解决问题？

##### 数组区间和的个数LeetCode327

&emsp;&emsp;给定一个数组arr，两个整数lower和upper，返回arr中有多少个子数组的累加和在[lower,upper]范围上。
&emsp;&emsp;可以使用归并排序、线段树、动态增加节点的线段树、树状数组、平衡二叉搜索树等方法结局。[LeetCode题解](https://leetcode.cn/problems/count-of-range-sum/solutions/)

###### 归并排序

* 由原数组得到前缀和数组sum，递归合并，在合并操作中统计区间个数
* 左边left...middle有序，右边middle+1...right有序，遍历右边每一个元素，拿到max、min。
* 因为左边有序拿到左边的上下限，则是包含sum[i]的区间和子数组的上下限。
* 左侧、右侧部分内部的区间和个数已经在上一步处理完。

##### 单链表荷兰国旗问题

&emsp;&emsp;遍历链表的时间复杂度是O(N)，链表节点的移动需要处理好next、记录pre。
// TODO
