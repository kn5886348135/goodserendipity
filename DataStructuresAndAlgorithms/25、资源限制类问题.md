---
title: 资源限制类问题
author: Louis
date: 2023-06-02 22:04:53
categories: 数据结构与算法
tags: [资源限制]
---

### 资源限制类问题技巧

1. 布隆过滤器用于集合的建立与查询，并可以节省大量空间
2. 一致性哈希解决数据服务器的负载管理问题
3. 利用并查集结构做岛问题的并行计算
4. 哈希函数可以把数据按照种类均匀分流
5. 位图解决某一范围上数字的出现情况，并可以节省大量空间
6. 利用分段统计思想、并进一步节省大量空间
7. 利用堆、外排序来做多个处理单元的结果合并

#### hash函数把数据按照种类均匀分流

1. 32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，可以使用最多1GB的内存，怎么找到出现次数最多的数？

&emsp;&emsp;将每一个数对400取模，分别存到400个小文件中。相同的数一定在同一个文件中，并且因为hash的均匀离散特性，每个文件中最多1000W数据(即使超过1000W，也不会超过太多)，内存不超过1G。另外新建小文件记录每个数和出现的次数的键值对。取出每一个文件中出现次数最多的数，取最大值。

2. 在上一个问题中，如果某一个数字出现了2000W次？

&emsp;&emsp;将每一个数对400取模后直接写入整数和它出现的次数的键值对，取出每一个文件中出现次数最多的数，取最大值。

#### 位图找出不存在的无符号整数

3. 32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然存在没出现过的数。可以使用最多1GB的内存，怎么找到所有未出现过的数？

&emsp;&emsp;使用bitmap或者数组保存0~4,294,967,295内的无符号整数，1GB=2^3^ $\times$ 2^10^ $\times$ 2^10^ $\times$ 2^10^ bit = 2^33^ bit，是可以保存所有0~4,294,967,295的无符号整数。遍历给定的文件，拿到某一个整数index，在bitmap的offset为index的二进制位修改为1，最后取出bitmap中所有二进制位为0的数，bitmap的所有二进制位都是0则是整数0。(2^32^长度的bit数组arr，出现过的数字num，将arr[num]标记成1，最后将没有出现过的数字列出即可。如果arr[index]==0，则index没有出现过。)
&emsp;&emsp;Set，需要约16G内存，位图，不超过1G内存。2^32^&ensp;&ensp;   bit = 2^29^&ensp;&ensp;   Byte = 2^19^&ensp;&ensp;   KB = 2^9^&ensp;&ensp;    MB = 2^-1^&ensp;&ensp;   GB

4. 32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多1GB的内存，找出所有出现了两次的数。

&emsp;&emsp;准备2^33^长度的bit数组arr，对任意无符号整数index，arr[2*index]、arr[2*index+1]表示index出现的次数
|序号|arr[2 $\times$ index]|arr[2 $\times$ index + 1]|含义            |
|--- |---------------------|-------------------------|----------------|
|1   |0                    |0                        |没有出现index    |
|2   |0                    |1                        |index出现1次     |
|3   |1                    |0                        |index出现2次     |
|4   |1                    |1                        |index出现3次及以上|

#### 分段统计

5. 32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然存在没出现过的数。内存限制为 10MB(3KB)，怎么找到任意一个没有出现的整数。

```Java
// 假设数组长度为10
int[] arr = new int[10];
int i = 179; // i &lt; 10 * 32
int status = (arr[i / 32] & (1 << (i % 32))) == 0 ? 0 : 1;
```

&emsp;&emsp;程序运行消耗的内存肯定不止3KB，这里的3KB是指用于分段的局部变量内存大小。
&emsp;&emsp;$512 \times 4$ Byte &lt; 3KB，将0-2^32^-1均分成512份，则每一份都应该有2^23^ = 8388608个无符号整数。准备数组arr，遍历整个文件，当前无符号整数num对512取模，结果为index，arr[index]记录每一个分段的无符号整数的个数。根据鸽笼原理，必有某一个arr[i]小于2^23^。继续拆分成512份，适当时候可以使用bitmap找到一个没有出现的无符号整数。

&emsp;&emsp;0~2^32^-1一共2^32^个数字，每个比特位为1和为0的无符号整数个数一定是相同的。遍历40亿个无符号整数，从最高位开始，每次取个数较小的比特位并记录。最多32次就可以获取某一个不存在的无符号整数。
<font color=red>// TODO 证明</font>

6. 只能申请几个有限的变量，找到40亿个数的文件中没有出现的(1-2^32^-1)范围内的数字？
&emsp;&emsp;准备left、mid、right将2^32^二分，个数较少的那部分一定有不存在的无符号整数。最多经过32次二分就可以得出结果。

### 布隆过滤器

7. 有一个包含100亿个URL的大文件，假设每个URL占用64Bit，请找出其中所有重复的URL。

&emsp;&emsp;布隆过滤器存在误判的可能，hash签名不会误判但需要更多的内存。将所有URL通过一到两次hash到若干个(10000)小文件中，最后统计小文件中重复的URL。

8. 某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门Top100词汇的可行办法。

&emsp;&emsp;大根堆是不可以的，没法获取每一个搜索词汇的频次，100亿URL的大根堆超过单机处理内存上限。可以使用hash或者布隆过滤器拿到所有搜索词出现的次数，再取出top100。使用前缀树、后缀树统计频次，利用重复的前缀节省空间。如果是中文、日文这种超大字符集的语言可以使用双数组字典树(Double-Array Trie)。

### 分段统计

9. 32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多3K的内存，怎么找到这40亿个整数的中位数？
1、准备int[] arr = new int[512]
2、统计将40亿个数按照512个一组分成若干份，统计每一组的频次
3、累加每组的频次，直到20亿

10. 32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多3K的内存，怎么找到这40亿个整数的上中位数(偶数个的时候前一个)？
1、准备int[] arr = new int[512]
2、统计将40亿个数按照512个一组分成若干份，统计每一组的频次
3、累加每组的频次，直到20亿

### 堆排序

11. 32位无符号整数的范围是0~4294967295，有一个10G大小的文件，每一行都装着这种类型的数字，整个文件是无序的，给你5G的内存空间，请你输出一个10G大小的文件，就是原文件所有数字排序的结果。

&emsp;&emsp;用自定义的堆或者数组保存前k个最小的无符号整数并排序，记录每个整数和出现的次数的键值对。若干次循环将整个文件的无符号整数排序。外部排序(分布式合并排序)可以忽视单机内存限制，二项堆(堆上堆、二维堆)也有单机内存限制。

  1. 将源文件复制一份
  2. 自定义一个小根堆，大小为2^28^次，正好1GB大小的Integer数据
  3. 从文件中读取逐行读取数字
    a. 如果堆没有满则进堆，在文件中删除这个数字，并记录数字和对应的频次
    b. 如果堆满并且小于堆中最大的数则进堆并且删除堆中最大的数，在文件中删除这个数字，并记录数字和对应的频次。更新堆中最大的数和位置。
    c. 如果堆满并且大于堆中的最大的数则继续读取文件中的数字并重复步骤3
  4. 文件读取完以后将堆中的数字读出并按照频次输出到目标文件
  5. 循环步骤3、4直到文件中没有数据
