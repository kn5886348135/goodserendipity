---
title: 链表、栈和队列
author: Louis
date: 2023-04-06 13:31:10
categories: 数据结构与算法
tags: 链表、栈、队列、递归
---

&emsp;&emsp;链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。

&emsp;&emsp;使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

&emsp;&emsp;链表有很多种不同的类型：单向链表，双向链表以及循环链表。单链表有一个next指针指向下一个节点，双链表有一个next和一个last指针，循环链表的头尾相连。

&emsp;&emsp;栈是数据先进后出，队列是数据先进先出。
&emsp;&emsp;链表、栈和队列相关的题目可以合理使用一些技巧，比如哈希表、有序表、数组、快慢指针等。

#### 递归

&emsp;&emsp;递归（英语：Recursion），在数学和计算机科学中是指在函数的定义中使用函数自身的方法，在计算机科学中还额外指一种通过重复将问题分解为同类的子问题而解决问题的方法。
&emsp;&emsp;任何递归都可以改成非递归方式实现。将系统压栈改为自定义实现，则可以避免递归。
&emsp;&emsp;例如递归求数组arr[L..R]中的最大值。

```Java
    1、将[L..R]范围分成左右两半。左：[L..Mid]  右[Mid+1..R]
    2、左部分求最大值，右部分求最大值
    3、[L..R]范围上的最大值，是max{左部分最大值，右部分最大值}
    注意：步骤2是个递归过程，当范围上只有一个数，就可以不用再递归了
    // 特别容易栈溢出
    private static int process(int[] arr, int left, int right) {
        // 递归终止条件
        if (left == right) {
            return Math.max(arr[left], arr[right]);
        }
        int middle = left + ((right - left) >> 1);
        int ans1 = process(arr, left, middle);
        int ans2 = process(arr, middle + 1, right);
        return Math.max(ans1, ans2);
    }
```

#### Master公式

&emsp;&emsp;master公式预估递归的时间复杂度，要求子问题数据规模一样。
&emsp;&emsp;形如T(N) = a *T($\frac{N}{b}$) + O(N^d^)(其中的a、b、d都是常数)的递归函数，可以直接通过Master公式来确定时间复杂度。
&emsp;&emsp; 如果 log(b,a) < d，时间复杂度为O(N^d^)
&emsp;&emsp; 如果 log(b,a) > d，时间复杂度为O(N^log(b,a)^)
&emsp;&emsp; 如果 log(b,a) == d，时间复杂度为O(N^d^* logN)

#### 哈希表

1. 哈希表在使用层面上可以理解为一种集合结构
2. 如果只有key，没有伴随数据value，可以使用HashSet结构
3. 如果既有key，又有伴随数据value，可以使用HashMap结构
4. 有无伴随数据，是HashMap和HashSet唯一的区别，实际结构是一回事
5. 使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 O(1)，但是常数时间比较大
6. 放入哈希表的东西，如果是基础类型，内部按值传递，内存占用是这个东西的大小
7. 放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是8字节

#### 有序表

1. 有序表在使用层面上可以理解为一种集合结构
2. 如果只有key，没有伴随数据value，可以使用TreeSet结构
3. 如果既有key，又有伴随数据value，可以使用TreeMap结构
4. 有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事
5. 有序表把key按照顺序组织起来，而哈希表完全不组织
6. 红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同
7. 放入如果是基础类型，内部按值传递，内存占用就是这个东西的大小
8. 放入如果不是基础类型，内部按引用传递，内存占用是8字节
9. 不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度
    - void put(K key, V value)将一个(key，value)记录加入到表中，或者将key的记录 更新成value。
    - V get(K key)根据给定的key，查询value并返回。
    - void remove(K key)移除key的记录。
    - boolean containsKey(K key)询问是否有关于key的记录。
    - K firstKey()返回所有键值的排序结果中，最小的那个。
    - K lastKey()返回所有键值的排序结果中，最大的那个。
    - K floorKey(K key)返回<= key 离key最近的那个
    - K ceilingKey(K key）返回>= key 离key最近的那个

#### 哈希表和有序表的优点

- 哈希表在使用时，增删改查时间复杂度都是O(1)
- 有序表在使用时，比哈希表功能多，时间复杂度都是O($log_N$)

------

##### 1、反转单链表和双链表

```Java
// 使用while循环，保存next节点，设置当前节点的next，保存pre，移动head，最后返回pre
private static Node reverseLinkedList(Node head) {
    Node pre = null;
    Node next = null;
    while (head != null) {
        next = head.getNext();
        head.next = pre;
        pre = head;
        head = next;
    }
    return pre;
}

// 使用while循环，保存next节点，设置当前节点的last和pre，保存pre，移动head，最后返回pre
private static Node reverDoubleLinkedList(Node head) {
    Node pre = null;
    Node next = null;
    while (head != null) {
        next = head.getLast();
        head.setLast(pre);
        head.setPre(next);
        pre = head;
        head = next;
    }
    return pre;
}
```

##### 2、删除单链表和双链表的指定值

##### 3、单链表实现队列和栈

##### 4、双向链表实现队列和栈

##### 5、使用双链表实现双端队列

- 单链表和双链表的新增、删除，主要注意处理好前驱和后继指针，必要的时候添加中间变量保存。双链表注意处理头尾重合、为空的边界条件。

##### 6、数组实现队列和栈

##### 7、数组实现不超过固定大小的队列和栈

- 栈：正常使用
- 队列：环形数组

##### 8、两个栈实现队列

##### 9、两个队列实现栈

##### 10、实现一个特殊的栈(一个栈保存min、一个栈正常操作)

- 实现方法push、pop、peek、empty、search，getMin
- pop、push、getMin操作的时间复杂度都是 O(1)。
- 设计的栈类型可以使用现成的栈结构。

##### 11、图的宽度优先搜索，使用队列实现，图的深度优先搜索，实现栈实现

##### 12、图的宽度优先搜索，使用栈实现，图的深度优先搜索，实现队列实现

##### 13、K个节点的组内逆序调整 LeetCode25

- k个一组，获取start和end
- 翻转start到end，将start指向end.next
- lastEnd = start，递归终止条件lastEnd.next != null

##### 14、两个链表相加 LeetCode2、LeetCode445

- 根据链表长度分三段处理，第一段处理短链表，第二段处理长链表多出的部分，第三段处理长链表最后的进位

##### 15、合并两个有序链表 LeetCode21

- 比较头结点，选取较小的那个作为返回链表的头部head
- 将head作为一个单独的链表，尾部记为pre
- 依次比较node1、node2，pre指向node1、node2较小的那个
- 返回head

##### 16、合并K个升序链表 LeetCode23

- 使用PriorityQueue保存各链表的头结点，链表的头结点是当前链表的最小值。每次prorityQueue.poll()弹出最小值，注意单链表的next指针和中间变量。循环终止条件为优先级队列变空。

##### 17、快慢指针/双指针

&emsp;&emsp;快慢指针一般用于链表成环、相交等场景，某些具有单调性的范围上的问题可以使用双指针，比如求正数数组中乘积小于k的连续子数组个数等。

1. 输入链表头节点，奇数长度返回中点，偶数长度返回上中点
2. 输入链表头节点，奇数长度返回中点，偶数长度返回下中点
3. 输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
4. 输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个

##### 18、判断链表是否回文结构

1. 辅助栈，遍历栈和单链表，每个元素相同则是回文链表
2. 拿到链表中点，将链表后半部分入栈，遍历单链表和栈
3. 将中点后的指针逆向，从两边遍历链表对比，然后将链表逆序部分还原。
4. 借助hash表，key保存链表位置，value保存链表值。取left和right位置比较，递归终止条件为left>right。

##### 19、寻找链表环入口

- 快慢指针，快指针走两步，慢指针走一步，如果快指针走到null仍未相遇则无环
- 假设链表在环中是顺时针的，在p点相遇时，慢指针走了m圈，快指针走了n圈
- 则2(c+m(a+b)+a) = c+n*(a+b)+a得出c=(n-2m-1)(a+b)+b
- n-2m-1是整数并且不小于0，如果小于0则c成负数
- 所以快指针从O点出发，每次走一步可以和慢指针在Q点相遇。
- ![证明辅助图](https://www.goodserendipity.com/asserts/data-structures-and-algorithms/%E9%93%BE%E8%A1%A8%E5%85%A5%E7%8E%AF%E7%82%B9%E8%AF%81%E6%98%8E.png)

##### 20、两个链表相交

&emsp;&emsp;给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null
&emsp;&emsp;要求如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。

- 要么都有环，要么都没环，一个有环一个没环无法相交。因为链表只有一个next指针，相交后的节点完全一样。
- 快慢指针获取链表入环节点
- 都没环，遍历两个链表，相交的两个链表尾结点一定相同。长链表先走len1-len2步，然后两个链表同时遍历，出现相同的节点即相交的第一个节点
- 都有环，环外相交同都没有环，环内相交则验证入环点在同一个环，返回任意一个入环点即可。

##### 21、链表分组、将单向链表按某值划分成左边小、中间相等、右边大的形式

- 把链表放入数组里，在数组上做partition
- 分成小、中、大三部分，再把各个部分之间串起来

##### 22、复制无环单链表

&emsp;&emsp;一种特殊的单链表节点类描述如下

```Java
class Node {
  int value;
  Node next;
  Node rand;
  Node(int val) { value = val; }
}
```

&emsp;&emsp;rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。
&emsp;&emsp;要求时间复杂度O(N)，额外空间复杂度O(1)

- 使用map保存节点和复制后的节点，设置next和random，返回map.get(head)
- 将复制后的节点插入原链表对应节点后，设置random，拆开链表。

##### 23、没有头结点，不能删除链表节点

&emsp;&emsp;不给单链表的头节点，只给想要删除的节点，没法删除这个节点。

  1. 给定的节点是头结点，可以删除
  2. 给定的节点是中间节点，把后面节点依次往前移动，只能将移动后的尾结点指向null，但无法删除尾结点
  3. 给定的节点是尾结点，也无法删除尾结点。只能将尾结点设置为null，但无法删除尾结点。
