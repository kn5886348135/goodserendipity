---
title: 时间复杂度
date: 2023-04-03 17:53:55
categories: 数据结构与算法
tags: 复杂度
---

#### 算法的5个特点

1. 有穷性
2. 确定性(确定的执行流程或者确定的尝试流程)
3. 可行性
4. 输入
5. 输出

#### 时间复杂度

&emsp;&emsp;评估算法优劣的核心指标

1. 时间复杂度（流程决定）
2. 额外空间复杂度（流程决定）
3. 常数项时间（实现细节决定）

##### 时间复杂度估算

- 常数时间的操作
- 确定算法流程的总操作数量与样本数量之间的表达式关系
- 只看表达式最高阶项的部分

##### 常数时间的操作

&emsp;&emsp;如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间。称这样的操作为常数时间的操作。

##### 常见的常数时间的操作

- 常见的算术运算（+、-、*、/、% 等）
- 常见的位运算（>>、>>>、<<、|、&、^等）
- 赋值、比较、自增、自减操作等
- 数组寻址操作

##### 确定算法流程的总操作数量与样本数量之间的表达式关系

1. 想象该算法流程所处理的数据状况，要按照最差情况来。
2. 把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作。
3. 如果数据量为N，看看基本动作的数量和N是什么关系。

##### 确定算法流程的时间复杂度

&emsp;&emsp;当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。记为：O(忽略掉系数的高阶项)。可以用选择排序、冒泡排序、插入排序练习估算时间复杂度。

##### 其他

1. 算法和具体的语言是无关的。
2. 一定要确保在拆分算法流程时，拆分出来的所有行为都是常数时间的操作。这意味着你写算法时，对自己的用过的每一个系统api，都非常的熟悉。否则会影响你对时间复杂度的估算。比如Java的LinkedList的get(int index)方法是需要遍历所有节点的，时间复杂度是O(N)。
3. 递归的时间复杂度可以使用master公式进行估算。

#### 时间复杂度的意义

&emsp;&emsp;当我们要处理的样本量很大很大时，低阶项和每一项的系数对算法执行的时间的影响和高阶项相比，可以忽略。它是衡量算法流程的复杂程度的一种指标，该指标只与数据量有关，与过程之外的优化无关。
&emsp;&emsp;同样时间复杂度的两个不同算法在具体运行的时候，时间也不一定一样。常数项和每一项的系数也是算法优化的一个方向。

#### 额外空间复杂度

&emsp;&emsp;在实现算法流程的过程中，需要开辟一些空间。作为输入参数的空间和作为输出结果的空间，不算额外空间。因为这些都是必要的、和现实目标有关的。除此之外，除此之外，算法流程中开辟的空间就是额外空间。如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。

&emsp;&emsp;一般情况下，一个问题的最优解，在时间复杂度的指标上，一定要尽可能的低，先满足了时间复杂度最低这个指标之后，使用最少的空间的算法流程。一般最优解都是忽略掉常数项这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。

#### 时间复杂度补充

&emsp;&emsp;常见的时间复杂度，排名从好到差：

- O(1)
- O(logN)
- O(N)
- O(N * logN)
- O(N^2^)   O(N^3^)   …   O(N^K^)
- O(2^N^)   O(3^N^)   …   O(K^N^)
- O(N!)

&emsp;&emsp;在Stack Overflow上有一个对算法复杂度表示方法O的[讨论](https://stackoverflow.com/questions/487258/what-is-a-plain-english-explanation-of-big-o-notation)，有一些关于时间复杂度更详细的表述。

&emsp;&emsp;算法的时间复杂度有平均时间复杂度、均摊时间复杂度、最差时间复杂度、最好时间复杂度几种情况。平均时间复杂度是所有输入的可能性相同时，算法运行时间的平均值。比如快排，因为选择partition的位置是随机的，最差时间复杂度是O(N^2^)，但是快排的平均时间复杂度是O($N \times log_N$)，认为最差的输入出现的概率很小。均摊时间复杂度是指算法中偶尔会出现一次比较昂贵的操作，比如O(N)，但是出现的频率比较小，均摊到所有操作上就是常数时间的操作，比如红黑树的平衡操作，不是每一次左旋、右旋以后都会执行平衡操作。
&emsp;&emsp;攻击者可能会构造特殊的输入让算法出现最坏时间复杂度，比如hash洪水攻击。Java8以前的HashMap是使用链表解决hash碰撞问题，Java8在HashMap中加入了红黑树，红黑树可以极大地降低时间复杂度，使恶意输入的攻击成本上升。带密钥哈希算法是解决hash flooding attack的另一种方法，比如[SipHash](https://en.wikipedia.org/wiki/SipHash)、[MurmurHash](https://en.wikipedia.org/wiki/MurmurHash)、[CityHash](https://github.com/google/cityhash)等。Google的[CityHash](https://opensource.googleblog.com/2011/04/introducing-cityhash.html)论文、
