---
title: 二分法
author: Louis
date: 2023-04-04 22:59:15
categories: 数据结构与算法
tags: 二分查找
---

## <center>二分法</center>

&emsp;&emsp;二分查找算法（英语：binary search algorithm），也称折半搜索算法（英语：half-interval search algorithm）[1]、对数搜索算法（英语：logarithmic search algorithm）[2]，是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。但有序不是使用二分的必要条件，只要能正确构建左右两侧的淘汰逻辑，就可以使用二分。

#### 二分查找算法的要点

- while循环递归
- 构造淘汰逻辑
- 移动left、right
- 递归终止条件

#### 二分法题目

1. 在一个有序数组中，找某个数是否存在
2. 在一个有序数组中，找>=某个数最左侧的位置
3. 在一个有序数组中，找<=某个数最右侧的位置
4. 局部最小值问题
5. 求有序数组给定区间元素的个数

&emsp;&emsp;使用while循环，根据arr[target]和arr[middle]的大小，移动left或者right。

```Java
    private static boolean binarySearch(int[] arr, int target) {
        // 边界条件
        if (arr == null || arr.length == 0) {
            return false;
        }
        int left = 0;
        int right = arr.length - 1;
        int middle;
        // 递归终止条件
        while (left <= right) {
            middle = left + ((right - left) >> 1);
            if (arr[middle] > target) {
                // target在middle左边
                right = middle - 1;
            } else if (arr[middle] < target) {
                // target在middle右边
                left = middle + 1;
            } else {
                // 找到target
                return true;
            }
        }
        return false;
    }

// 大于等于target最左的位置
    private static int binarySearchLeft(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int left = 0;
        int right = arr.length - 1;
        int middle;
        int index = -1;
        // 当left + 1 = right时，如果while条件为left < right则会漏掉right
        while (left <= right) {
            middle = left + ((right - left) >> 1);
            if (arr[middle] < target) {
                left = middle + 1;
            } else {
                index = middle;
                right = middle - 1;
            }
        }
        return index;
    }

// 小于等于target最右的位置
    public static int binarySearchRight(int[] arr, int value) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int left = 0;
        int right = arr.length - 1;
        int middle;
        int index = -1;
        while (left <= right) {
            middle = left + ((right - left) >> 1);
            if (arr[middle] > value) {
                right = middle - 1;
            } else {
                index = middle;
                left = middle + 1;
            }
        }
        return index;
    }
```

&emsp;&emsp;在while循环中递归，总是能构造淘汰逻辑，所以可以使用二分法查找到一个局部最小值。如果arr[0]和arr[arr.length-1]都不是局部最小值，那么中间必然存在最小值，满足递归之后依然满足或者递归终止。

```Java
    public static int localMin(int[] arr) {
        // 边界条件
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int len = arr.length;
        if (len == 1 || arr[0] < arr[1]) {
            return 0;
        }
        if (arr[len - 1] < arr[len - 2]) {
            return len - 1;
        }
        int left = 1;
        int right = len - 2;
        int mid;
        // 开始二分
        while (left < right) {
            mid = left + ((right - left) >> 1);
            // 左边
            if (arr[mid] > arr[mid - 1]) {
                right = mid - 1;
            } else if (arr[mid] > arr[mid + 1]) {
                // 右边
                left = mid + 1;
            } else {
                // 找到局部最小值
                return mid;
            }
        }
        return left;
    }
```
