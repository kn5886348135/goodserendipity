---
title: 动态规划的其它优化技巧
author: Louis
date: 2023-08-10 16:44:48
categories: 数据结构与算法
tags: [动态规划的优化]
---

### 打爆气球

&emsp;&emsp;给定一个数组 arr，代表一排有分数的气球。每打爆一个气球都能获得分数，假设打爆气 球 的分数为 X，获得分数的规则如下:

1. 如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R。 获得分数为 $L \times X \times R$。
2. 如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边所有气球都已经被打爆。获得分数为 $L \times X$。
3. 如果被打爆气球的左边所有的气球都已经被打爆;如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R;如果被打爆气球的右边所有气球都 已经 被打爆。获得分数为 $X \times R$。
4. 如果被打爆气球的左边和右边所有的气球都已经被打爆。获得分数为 X。

&emsp;&emsp;目标是打爆所有气球，获得每次打爆的分数。通过选择打爆气球的顺序，可以得到不同的总分，请返回能获得的最大分数。
&emsp;&emsp;例如arr = {3,2,5} 如果先打爆3，获得 $3 \times 2$ ;再打爆2，获得 $2 \times 5$ ;最后打爆5，获得5;最后总分21 如果先打爆3，获得 $3 \times 2$ ;再打爆5，获得 $2 \times 5$ ;最后打爆2，获得2;最后总分18 如果先打爆2，获得 $3 \times 2 \times 5$ ;再打爆3，获得 $3 \times 5$ ;最后打爆5，获得5;最后总分50 如果先打爆2，获得 $3 \times 2 \times 5$ ;再打爆5，获得 $3 \times 5$ ;最后打爆3，获得3;最后总分48 如果先打爆5，获得 $2 \times 5$ ;再打爆3，获得 $3 \times 2$ ;最后打爆2，获得2;最后总分18 如果先打爆5，获得 $2 \times 5$;再打爆2，获得 $3 \times 2$;最后打爆3，获得3;最后总分19 返回能获得的最大分数为50

### 移除盒子

&emsp;&emsp;给出一些不同颜色的盒子 boxes ，盒子的颜色由不同的正数表示。你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k &ge; 1），这样一轮之后你将得到 $k \times k$ 个积分。返回 你能获得的最大积分和 。

### 消除字符

&emsp;&emsp;如果一个字符相邻的位置没有相同字符，那么这个位置的字符出现不能被消掉。比如:"ab"，其中a和b都不能被消掉。如果一个字符相邻的位置有相同字符，就可以一起消掉。比如:“abbbc”，中间一串的b是可以被消掉的，消除之后剩下“ac”。某些字符如果消掉了，剩下的字符认为重新靠在一起。给定一个字符串，你可以决定每一步消除的顺序，目标是请尽可能多的消掉字符，返回最少的剩余字符数量。比如："aacca", 如果先消掉最左侧的"aa"，那么将剩下"cca"，然后把"cc"消掉，剩下的"a"将无法再消除，返回1。但是如果先消掉中间的"cc"，那么将剩下"aaa"，最后都消掉就一个字符也不剩了，返回0，这才是最优解。再比如："baaccabb"，如果先消除最左侧的两个a，剩下"bccabb"，如果再消除最左侧的两个c，剩下"babb"，最后消除最右侧的两个b，剩下"ba"无法再消除，返回2。而最优策略是：先消除中间的两个c，剩下"baaabb"，再消除中间的三个a，剩下"bbb"，最后消除三个b，不留下任何字符，返回0，这才是最优解。

### 子数组最大累加和

&emsp;&emsp;给定一个数组arr，和一个正数M，返回在arr的子数组在长度不超过M的情况下，最大的累加和。

### LeetCode664 奇怪的打印机

&emsp;&emsp;有台奇怪的打印机有以下两个特殊要求：

1. 打印机每次只能打印由 同一个字符 组成的序列。
2. 每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。

&emsp;&emsp;给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。

### 还原数组

&emsp;&emsp;整型数组arr长度为n(3 &le; n &le; $10^4$)，最初每个数字是 &le; 200的正数且满足如下条件：

1. arr[0] &le; arr[1]
2. arr[n-1] &le; arr[n-2]
3. arr[i] &le; max(arr[i-1], arr[i+1])

&emsp;&emsp;但是在arr有些数字丢失了，比如k位置的数字之前是正数，丢失之后k位置的数字为0。请你根据上述条件， 计算可能有多少种不同的arr可以满足以上条件。比如 [6,0,9] 只有还原成 [6,9,9]满足全部三个条件，所以返回1种。
