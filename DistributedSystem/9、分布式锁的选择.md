---
title: 分布式锁的选择
author: Louis
date: 2023-08-27 22:00:18
categories: [Distributed System]
tags: [DLM, distributed locking]
---

&emsp;&emsp;分布式锁的可选方案有基于Redis的Redlock、zookeeper、Chubby(非开源)等。个人倾向于选择Redlock。

|序号|名称     |是否异步模型|可用性|可靠性|性能|
|---|---------|-----------|-----|------|----|
|1  |Redlock  |否         |高   |低     |高  |
|2  |zookeeper|是         |低   |高     |低  |
|3  |Chubby   |(待考证)   |高   |高     |低  |

&emsp;&emsp;[The Chubby lock service for loosely-coupled distributed systems](https://www.goodserendipity.com/asserts/distributed-system/The%20Chubby%20lock%20service%20for%20loosely-coupled%20distributed%20systems.pdf)自称设计重点是可用性和可靠性，是有人在忽悠我还是它抛弃了CAP理论的分区容错性？

&emsp;&emsp;在分布式锁的技术方案选择的时候主要考虑以下几点

1. 互斥，锁的基本特征，必须满足。
2. 自动释放锁，当某个客户端崩溃并且没有自动释放锁的功能，此时造成死锁。
3. 是否需要异步模型
    1. 异步模型不对Network Delay、Process Pause、Clock Drift问题做任何假设，不会返回错误结果，但返回结果可能不及时，也就是降低了可用性。
    2. zookeeper是标准的异步模型，但Redlock对Clock Drift做了一定程度的假设，获取锁之前在算法层面避免了Network Delay、Process Pause问题。
    3. 避免Linux系统管理员手动修改系统时间、正确配置nptd服务保证多次小碎步步进时间，Redlock的这个假设在获取锁之前是否合理，在工程实践上是否可以被接受？
    4. 在zookeeper方案中，Network Delay、Process Pause也可以导致多个客户端同时获取同一个锁。例如客户端A获取锁后因为Network Delay、Process Pause导致session过期，zookeeper会将节点锁删除，客户端B获取到锁，此时客户端A的Network Delay、Process Pause问题恢复，则造成客户端A和客户端B同时持有共享资源的锁。
4. 在写共享资源完成前，Network Delay、Process Pause、Clock Drift造成的锁失效问题，这是所有涉及带自动释放锁功能的分布式锁服务的项目必须要考虑的问题。
    1. 分布式锁服务需要提供递增序列，共享资源需要增加检查递增序列的功能。目前只有Chubby提供了解决方案，但它是不开源的。
    2. 维护基础设施保证高质量的网络，优化代码避免长时间的Process Pause，合格的系统管理员一定没有手痒的毛病，随便修改系统时钟。
    3. 可以使用锁的随机value做CAS操作避免多个锁同时更新一个共享资源。具体的CAS操作实现需要具体分析。
    4. 针对库存超卖问题，可以准备一定数量的备品或者提供退货服务作为兜底方案。库存保存在另一个Redis集群中，使用lua脚本的原子操作特性，先判断库存再扣减库存。Redlock降低了多个客户端同时扣减库存的概率，使用lua脚本扣减库存是防止极端场景下多个客户端获取了同一个库存的锁。极端场景多个客户端获取同一个锁来扣减库存，并且并发量飙升怎么办？限流？
    5. ~~在锁的value里面保存递增序列，在尝试获取锁的时候检查递增序列，并保证原子操作。每个锁在被获取的同时原子地递增value值并保存，这样可以拿到递增序列。可以检查递增序列就不再需要分布式锁服务了，Redission是否提供这样的递增序列？~~
    6. 缓存库存的Redis是另一个集群，集群部署的共享资源自己保证修改数据的正确性，例如主节点崩溃重启后怎么恢复数据？备品和退货服务作为兜底策略。
5. 性能问题，zookeeper通过监听通知客户端去尝试获取锁，Redlock通过有限次不断的重试来尝试获取锁。但zookeeper是强一致性的，必须保证<font color="red">多数(所有)</font>节点写入磁盘成功，Redlock是基于Redis的内存操作，所以Redlock的并发更高，可以达到10W+/s。使用MySQL的乐观锁(增加version列，update语句的时候检查version并递增更新version)，但并发较低。
6. Redis集群的节点崩溃延迟重启，延迟时间必须大于锁的TTL。超过半数节点崩溃，系统就无法获取到锁。启动Redis的fsync配置可以立马重启，但会降低并发量。
7. Redlock服务的Redis集群和用于缓存的Redis集群必须是两个不同的集群。
8. 锁的粒度问题，<font color="red">Chubby是粗粒度的锁，zookeeper可以控制锁粒度大小</font>，redis可以将库存分段加锁来控制锁粒度的大小。
9. Redlock的客户端重试尝试获取锁的间隔是随机的，多个客户端同时获取同一个共享资源的锁可能导致脑裂现象。
10. 适当的Jepsen测试。
